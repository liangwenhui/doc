# 事务处理
事务处理，存在的意义是为了保证系统中数据是符合期望的，具有一致性。

- 目标: 一致性 Consistency
- 原子性 Atomic
- 隔离性 Isolation
- 持久性 Durability

简称ACID 事务四种属性，但是注意的是 CID是事务的手段、C是目标。

通常，事务都会联想到数据库，因为事务的概率起源于数据库系统，但是现在分布式系统下，远远不止，所有需要保证事务一致性的场景，都可以用事务。

通常AID 在【内部一致性】的情况下，也就是单一数据源时，是非常好实现的。
但是在【外部一致性】的情况下，也就是多个数据源，比如（redis + db、或者+ mq），就很难通过AID来完成，通常需要付出较大的代价。但是在分布式系统中，外部一致性是一个无法避免的场景，比如交易系统中、支付-订单-库存 之间如何实现一致性。

所以，事务处理并不是简单的编程问题，往往是在业务 与 技术之间，需要权衡的 架构问题。

## 本地事务
本地事务指的是仅仅操作单一数据源，不需要全局事务管理器介入，最多只对事务接口接一层标准化的包装，比如JDBC接口，并不能深入参与事务的运作过程，事务的开启、终结、提交、回滚、嵌套、设置隔离级别等等，乃至于事务的传播都需要依赖底层数据源的支持。比如mongo不支持事务，就没办法使用事务。

比如在Java代码中使用JDBC的 Transaction::rollback(),虽然调用成功，但是并不表明真的回滚了，如果使用的是MyISAM，那rollback就是空实现。

## 实现原子性 A 和持久性 D

- 原子性
    -  保证事务的多个操作同时全部生效或者全部失败，不存在中间状态
- 持久性
    - 事务一旦成功，就不会因为任何原因导致数据修改或丢失

众所周知，数据必须落盘才会拥有持久性，只储存在内存中的数据一旦程序奔溃，甚至是服务器断电宕机的情况，就会丢失。实现原子性的难度在于 写入磁盘本身的操作就不是原子的，一批数据不仅仅有【写入】和【未写入】的状态，还有【正在写】，由于写入状态与崩溃是不可消除的问题，所以单纯把内存的数据刷到磁盘中，并不代表具备原子性和持久性。

下面列举一下可能会发生的情景
- 未提交事务，写入过程崩溃： 事务还没有完成，但是部分数据写入磁盘，部分没有。导致重启后数据不完整，必须要有办法得知奔溃前发生过一次不完整的操作，并且将部分写入磁盘的数据恢复到还没修改之前，保证原子性。
- 已提交事务，写入前奔溃：事务提交，程序已经任务事务正常结束，但是在写入磁盘之前发生奔溃。必须要找到奔溃前还没写入到磁盘的记录，并且重新执行，保证持久性。
由于不可消除写入操作的中间态与不可预测的崩溃，为了保证原子性和持久化，必须通过恢复的补救措施，这种行为叫做”崩溃恢复“

```
除了原子性和持久性，还有另一种事务方式 ：Shadow Paging 影子分页
大体思路是对数据的变动不直接修改数据本身，而是复制一份副本，修改副本的数据，在事务过程中会存在2分数据，当事务提交之后，说有数据都修改成功后，最后一步是将数据的引用指针修改为副本（修改指针被认为是原子操作）。
```

Commit Logging 保障持久性和原子性：日志一旦写入Commit Logging成功，则事务成功，即使磁盘的数据还没修改到，重启之后，仍然可以根据已经写入磁盘的日志进行恢复，保证了持久性。如果日志还没有成功写入Commit Record，事务是失败的，重启后会看到一部分没有Commit Record的日志，将这部分日志标记为回滚即可，整个事务像没发生过一样。

阿里的Ocean Base就是用了这种方式，这个方式有一个巨大的缺点，就是所有数据的修改都是在事务完成之后，即使当前资源的利用率不高，但还是必须等到事务成功之后，再进行数据的修改。（事务成功，但是数据还没写入，那需要读内存），对性能十分不利，或者需要特殊规格的硬件支持。

为此，ARIES提出了改进方案，Write-Ahead Logging的日志方案，就是允许事务提交之前就更新数据。
按照事务提交时间点，将何时变动数据划分为FORCE和STEAL两类情况

- FORCE：当事务提交后，要求变动数据必须同时完成。 不强制变动数据必须完成写入是 NO-FORCE。（就是刷盘时机）绝大多数数据库都是NO-FORCE，因为只要有了日志，变动数据随时可以持久化，从优化磁盘io性能考虑，没有必要强制数据写入时立即进行。

- STEAL：在事务提交之前，允许数据变更提前写入的是STEAL，不允许则是NO-STEAL。运行提前写入，有利于利用空闲资源，也节省数据行缓存、内存使用。

Write-Ahead Logging 允许NO-FORCE 和 STEAL，给出的解决方案是增加另一种被称为Undo Log的日志类型，当数据写入磁盘的时候，必须先记录Undo Log，注明修改的位置，从什么值改为什么值，以便于在崩溃恢复的时候，用于对提前写入的数据进行回滚。一般也称为回滚日志。此前用于记录崩溃恢复时用于操作重放的被称为Redo log。由于Undo Log的加入，WAL在崩溃恢复时会经历三个阶段

1. 分析阶段，从最后一次的检查点（Checkpoint，可以理解为在CP之前的数据都已经持久化）开始扫描日志，找出所有没有End Record的事务，组成待恢复事务集合，这个集合至少包括 事务表 和 脏页表。

2. 重做阶段（redo），在事务集合中找到待恢复的事务来重放，具体是找到所有包含Commit Record的日志，将日志操作重新写入磁盘，写入完成后加上End Record，将事务移除集合。

3. 回滚阶段（undo），重做之后，剩下的都是需要回滚的事务，依据log的记录进行回滚磁盘数据。

重做阶段与回滚阶段，都应该设计为幂等的。

